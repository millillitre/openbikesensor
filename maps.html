<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tracks maps</title>

  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"
  />

  <style>
    body {
      font-family: Arial, sans-serif;
    }
    #map {
      height: 600px;
      width: 100%;
    }
  </style>
</head>

<body class="iframe-page">

<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

<script>

const API_URL = "https://lilied-subprofessionally-mafalda.ngrok-free.dev/api/measurements";
const API_KEY = "openbikecle";
const MAX_GAP_SECONDS = 5; // seuil de séparation des traces

const map = L.map("map").setView([43.6001, 1.4419], 13);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "© OpenStreetMap"
}).addTo(map);


function toTimestamp(p) {
  return new Date(
    p.year,
    p.month - 1,
    p.day,
    p.hour,
    p.minute,
    p.second
  ).getTime();
}

function groupIntoTraces(points, maxGapSeconds) {
  const traces = [];
  let current = [];

  // Trier du plus ancien au plus récent
  const sorted = [...points].sort(
    (a, b) => toTimestamp(a) - toTimestamp(b)
  );

  for (let i = 0; i < sorted.length; i++) {
    if (current.length === 0) {
      current.push(sorted[i]);
      continue;
    }

    const prev = current[current.length - 1];
    const gap =
      (toTimestamp(sorted[i]) - toTimestamp(prev)) / 1000;

    if (gap > maxGapSeconds) {
      traces.push(current);
      current = [];
    }

    current.push(sorted[i]);
  }

  if (current.length > 0) {
    traces.push(current);
  }

  return traces;
}

function randomColor() {
  return `hsl(${Math.random() * 360}, 70%, 45%)`;
}

async function loadTrackData() {
  try {
    const response = await fetch(API_URL, {
      headers: {
        "X-API-KEY": API_KEY,
        "ngrok-skip-browser-warning": "true"
      }
    });

    if (!response.ok) {
      throw new Error("Erreur HTTP " + response.status);
    }

    let data = await response.json();

    const traces = groupIntoTraces(data, MAX_GAP_SECONDS);

    traces.forEach((trace, index) => {
      const color = randomColor();
      const coords = trace.map(p => [p.lat, p.lng]);

      // Trace (ligne)
      L.polyline(coords, {
        color: color,
        weight: 3,
        opacity: 0.8
      }).addTo(map);

      // Points
      trace.forEach(p => {
        const pointColor = p.speed_kmh > 30 ? 'red' : 'green';
        L.circleMarker([p.lat, p.lng], {
          radius: 3,
          fillColor: pointColor,
          color: pointColor,
          weight: 1,
          fillOpacity: 0.9
        })
        .addTo(map)
        .bindPopup(`
          <strong>Date</strong> : ${p.day}/${p.month}/${p.year}<br>
          <strong>Heure</strong> : ${p.hour}:${p.minute}:${p.second}<br>
          <strong>Vitesse</strong> : ${p.speed_kmh.toFixed(1)} km/h<br>
          <strong>Distance</strong> : ${p.distanceMin_cm} cm
        `);
      });
    });

    if (traces.length > 0) {
      map.fitBounds(
        traces.flat().map(p => [p.lat, p.lng])
      );
    }

  } catch (error) {
    console.error("Erreur chargement:", error);
    alert("Impossible de charger les données");
  }
}

loadTrackData();
</script>


</body>
</html>